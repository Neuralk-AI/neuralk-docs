"use strict";(globalThis.webpackChunkdocs_neuralk=globalThis.webpackChunkdocs_neuralk||[]).push([[9992],{8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var i=t(6540);const a={},s=i.createContext(a);function r(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(s.Provider,{value:n},e.children)}},9153:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"models","title":"Neuralk AI Tabular Foundation Models","description":"At Neuralk AI we develop powerful TFMs specifically purpose-built for industry applications, delivering state-of-the-art accuracy on real-world ML tasks across commerce, finance, healthcare and beyond. Below we give more details on its usage, limitations and setup recommendations.","source":"@site/docs/models.mdx","sourceDirName":".","slug":"/models","permalink":"/docs/models","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Glossary","permalink":"/docs/glossary"},"next":{"title":"Classification tutorial","permalink":"/docs/classification"}}');var a=t(4848),s=t(8453),r=t(4783);const o={sidebar_position:3},l="Neuralk AI Tabular Foundation Models",d={},c=[{value:"NICL (Neuralk In-Context Learning)",id:"nicl-neuralk-in-context-learning",level:2},{value:"Size of input",id:"size-of-input",level:3},{value:"When to use",id:"when-to-use",level:3},{value:"In-Context Learning (ICL)",id:"in-context-learning-icl",level:3},{value:"Context (TFMs) vs Prompts (LLMs): what&#39;s the difference?",id:"context-tfms-vs-prompts-llms-whats-the-difference",level:4},{value:"Limitations",id:"limitations",level:3},{value:"Data Preparation",id:"data-preparation",level:3},{value:"Maximising Correctness",id:"maximising-correctness",level:3},{value:"Balancing Sample Size and Context Window",id:"balancing-sample-size-and-context-window",level:3}];function p(e){const n={admonition:"admonition",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"neuralk-ai-tabular-foundation-models",children:"Neuralk AI Tabular Foundation Models"})}),"\n",(0,a.jsx)(n.p,{children:"At Neuralk AI we develop powerful TFMs specifically purpose-built for industry applications, delivering state-of-the-art accuracy on real-world ML tasks across commerce, finance, healthcare and beyond. Below we give more details on its usage, limitations and setup recommendations."}),"\n",(0,a.jsx)(r.A,{className:"button button--secondary button--quickstart",to:"/docs/classification",children:(0,a.jsx)(n.p,{children:"Get started"})}),"\n",(0,a.jsx)(n.h2,{id:"nicl-neuralk-in-context-learning",children:"NICL (Neuralk In-Context Learning)"}),"\n",(0,a.jsx)(n.p,{children:"NICL is designed for tabular prediction tasks (classification) where patterns can be inferred directly from the data distribution without extensive model tuning."}),"\n",(0,a.jsx)(n.h3,{id:"size-of-input",children:"Size of input"}),"\n",(0,a.jsx)(n.p,{children:"NICL performs best on datasets with up to 250 features and 15,000 samples, offering reliable and consistent performance out of the box."}),"\n",(0,a.jsx)(n.p,{children:"For larger problems, NICL can scale to 1 million samples and 500 features, though performance may vary depending on input complexity."}),"\n",(0,a.jsx)(n.h3,{id:"when-to-use",children:"When to use"}),"\n",(0,a.jsx)(n.p,{children:"NICL is ideal when you:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Need strong baseline performance without hyper-parameter tuning."}),"\n",(0,a.jsx)(n.li,{children:"Want a unified approach to handle mixed feature types."}),"\n",(0,a.jsx)(n.li,{children:"Are exploring new datasets and want fast iteration."}),"\n",(0,a.jsx)(n.li,{children:"Prefer interpretability and flexible prompting over black-box optimisation."}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"in-context-learning-icl",children:"In-Context Learning (ICL)"}),"\n",(0,a.jsx)(n.p,{children:"In-Context Learning (ICL) is a process where a model makes predictions based on contextual examples provided directly within the input, rather than by updating its internal parameters through traditional training methods. This approach is particularly advantageous in situations where labeled data is scarce or frequently changing."}),"\n",(0,a.jsx)(n.p,{children:"For models such as NICL, this means that a small set of input\u2013output pairs, the context acts as a description of the task at hand. The model uses this contextual information to infer relationships and predict outcomes for new samples. In doing so, it effectively adapts to new datasets without further model retraining."}),"\n",(0,a.jsx)(n.h4,{id:"context-tfms-vs-prompts-llms-whats-the-difference",children:"Context (TFMs) vs Prompts (LLMs): what's the difference?"}),"\n",(0,a.jsx)(n.p,{children:"In-Context Learning in models like NICL is conceptually similar to how Large Language Models (LLMs) use prompts. In both cases, the model does not update its internal parameters but instead conditions its predictions on the information provided in the input. For an LLM, the prompt is a set of  examples, instructions, or context and it defines the task and guides the model\u2019s next output. Likewise, in NICL, the context of labeled examples serves as a prompt that betters defines the task and guides the model\u2019s predictions."}),"\n",(0,a.jsx)(n.p,{children:"Both approaches rely on the model\u2019s ability to interpret patterns from context and generalise to unseen instances, demonstrating a shared principle: learning and running inferences directly from input rather than through explicit retraining."}),"\n",(0,a.jsx)(n.h3,{id:"limitations",children:"Limitations"}),"\n",(0,a.jsx)(n.p,{children:"While NICL provides excellent generalisation across a wide range of datasets for very high-dimensional or sparse data (e.g., text bag-of-words, one-hot expansions) it may require further preprocessing steps to achieve optimal performance."}),"\n",(0,a.jsx)(n.h3,{id:"data-preparation",children:"Data Preparation"}),"\n",(0,a.jsx)(n.p,{children:"NICL is designed to work with minimal preprocessing. In most cases, you can pass your dataset as a clean tabular structure (e.g., pandas DataFrame) and obtain strong performance."}),"\n",(0,a.jsx)(n.p,{children:"However, you can improve accuracy and stability by following a few simple practices:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Handle missing values (imputation or explicit missing indicators)."}),"\n",(0,a.jsx)(n.li,{children:"Encode categorical features as integers consistently across training and inference."}),"\n",(0,a.jsx)(n.li,{children:"Keep feature semantics consistent between training and prediction."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.em,{children:"Expert-based preprocessing or domain-specific feature engineering can further enhance results, but NICL is intentionally built to work well \u201cas is.\u201d"})}),"\n",(0,a.jsx)(n.h3,{id:"maximising-correctness",children:"Maximising Correctness"}),"\n",(0,a.jsx)(n.p,{children:"Unlike traditional ML models, NICL does not rely on hyper-parameter tuning or fine-tuning. Instead, its performance can often be improved through prompt design and context specification."}),"\n",(0,a.jsx)(n.p,{children:"When working with NICL:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Include representative samples to help NICL infer feature importance and relationships."}),"\n",(0,a.jsx)(n.li,{children:"Experiment with context to help NICL focus on the most relevant aspects of your data."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.em,{children:"Think of NICL as a reasoning engine for tabular data: the clearer the context, the more accurate the inference."})}),"\n",(0,a.jsx)(n.h3,{id:"balancing-sample-size-and-context-window",children:"Balancing Sample Size and Context Window"}),"\n",(0,a.jsx)(n.p,{children:"NICL operates within a\xa0finite context window, typically up to a few hundred thousand rows. This means more examples are not always better. The best performance often comes from a\xa0compact, informative subset\xa0rather than a full dataset dump."}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Too\xa0few samples: might lead to underfitting and poor generalization."}),"\n",(0,a.jsx)(n.li,{children:"Too\xa0many samples: might cause context dilution, slow down inference and introduce noise."}),"\n",(0,a.jsx)(n.li,{children:"Optimal: give diverse, non-redundant examples as context."}),"\n"]}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsx)(n.p,{children:"A practical heuristic: Start with 1,000\u2013100,000 representative samples. Increase gradually until you reach diminishing returns."})}),"\n",(0,a.jsx)(n.admonition,{type:"note",children:(0,a.jsx)(n.p,{children:"While NICL currently operates on numerical inputs, future versions coming soon will include native support for textual data."})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(p,{...e})}):p(e)}}}]);